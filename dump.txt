
	// db, err := sql.Open("postgres", "user=postgres password=mypassword dbname=postgres sslmode=disable")
	// if err != nil {
	// 	fmt.Println("Could not connect to the database:", err)
	// 	os.Exit(1)
	// }
	// defer db.Close()

	// createTable(db)
	// if *domain != "" && *answer != "" {
	// 	insertRecord(db, *domain, *typeFlag, *classFlag, *answer, *auth)
	// 	return
	// }

    
	// port := flag.Int("port", 53, "Port to run the DNS server on")
	// domain := flag.String("domain", "", "Domain to insert")
	// typeFlag := flag.String("type", "A", "Record type")
	// classFlag := flag.String("class", "IN", "Record class")
	// answer := flag.String("answer", "", "Record answer")
	// auth := flag.Bool("auth", false, "Authoritative flag")
	// flag.Parse()

    

// func createTable(db *sql.DB) {
// 	query := `
// 	CREATE TABLE IF NOT EXISTS dns_records (
// 		id SERIAL PRIMARY KEY,
// 		domain VARCHAR(255) NOT NULL,
// 		type VARCHAR(10) NOT NULL,
// 		class VARCHAR(10) NOT NULL,
// 		answer TEXT NOT NULL,
// 		authoritative BOOLEAN NOT NULL
// 	);
// 	`
// 	_, err := db.Exec(query)
// 	if err != nil {
// 		fmt.Println("Failed to create table:", err)
// 		os.Exit(1)
// 	} else {
// 		fmt.Println("Table dns_records is ready")
// 	}
// }
// func queryDatabase(db *sql.DB, domain string, rrType uint16, rrClass uint16) (string, bool, bool) {
// 	var answer string
// 	var authoritative bool

// 	typeStr, okType := dnslookup.RRTypeMap[rrType]
// 	classStr, okClass := dnslookup.RRClassMap[rrClass]

// 	if !okType || !okClass {
// 		return "", false, false
// 	}

// 	query := `SELECT answer, authoritative FROM dns_records WHERE domain=$1 AND type=$2 AND class=$3`
// 	row := db.QueryRow(query, domain, typeStr, classStr)
// 	err := row.Scan(&answer, &authoritative)
// 	if err == sql.ErrNoRows {
// 		return "", false, false
// 	} else if err != nil {
// 		fmt.Printf("Database query error: %v\n", err)
// 		return "", false, false
// 	}

// 	return answer, authoritative, true
// }
// func insertRecord(db *sql.DB, domain, rtype, class, answer string, authoritative bool) {
// 	query := `INSERT INTO dns_records (domain, type, class, answer, authoritative) VALUES ($1, $2, $3, $4, $5)`
// 	_, err := db.Exec(query, domain, rtype, class, answer, authoritative)
// 	if err != nil {
// 		fmt.Println("Failed to insert DNS record:", err)
// 	} else {
// 		fmt.Println("Record inserted successfully")
// 	}
// }




package main

import (
	"fmt"
	"net"
	"os"
	"time"

	"github.com/hashicorp/golang-lru/v2/expirable"
	_ "github.com/lib/pq"
	dnslookup "github.com/sohamjoshi25/go-dns-server/dnslookup"
	dnsproxy "github.com/sohamjoshi25/go-dns-server/dnsproxy"
)

func main() {

	cache := expirable.NewLRU[dnslookup.DNSQuestion, []dnslookup.DNSAnswer](16, nil, time.Minute*5)

	fmt.Printf("DNS Server Running on port 53")

	addr := net.UDPAddr{
		Port: 53,
		IP:   net.ParseIP("0.0.0.0"),
	}

	conn, err := net.ListenUDP("udp", &addr)
	if err != nil {
		fmt.Println("Could not start server:", err)
		os.Exit(1)
	}
	defer conn.Close()

	for {
		dnsproxy.HandleDNSRequest(conn, cache)
	}
}
